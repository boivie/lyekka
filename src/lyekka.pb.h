// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lyekka.proto

#ifndef PROTOBUF_lyekka_2eproto__INCLUDED
#define PROTOBUF_lyekka_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace Lyekka {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_lyekka_2eproto();
void protobuf_AssignDesc_lyekka_2eproto();
void protobuf_ShutdownFile_lyekka_2eproto();

class TreeRef;
class Part;
class FileEntry;
class Tree;
class Property;
class Properties;
class SecureProperties;
class Pbkdf2Key;
class PgpKey;
class EncryptedProperties;
class Manifest;
class Signature;

enum Encryption {
  AES_128_CBC = 1
};
bool Encryption_IsValid(int value);
const Encryption Encryption_MIN = AES_128_CBC;
const Encryption Encryption_MAX = AES_128_CBC;
const int Encryption_ARRAYSIZE = Encryption_MAX + 1;

const ::google::protobuf::EnumDescriptor* Encryption_descriptor();
inline const ::std::string& Encryption_Name(Encryption value) {
  return ::google::protobuf::internal::NameOfEnum(
    Encryption_descriptor(), value);
}
inline bool Encryption_Parse(
    const ::std::string& name, Encryption* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Encryption>(
    Encryption_descriptor(), name, value);
}
enum Compression {
  ZLIB = 0,
  NONE = 1
};
bool Compression_IsValid(int value);
const Compression Compression_MIN = ZLIB;
const Compression Compression_MAX = NONE;
const int Compression_ARRAYSIZE = Compression_MAX + 1;

const ::google::protobuf::EnumDescriptor* Compression_descriptor();
inline const ::std::string& Compression_Name(Compression value) {
  return ::google::protobuf::internal::NameOfEnum(
    Compression_descriptor(), value);
}
inline bool Compression_Parse(
    const ::std::string& name, Compression* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Compression>(
    Compression_descriptor(), name, value);
}
// ===================================================================

class TreeRef : public ::google::protobuf::Message {
 public:
  TreeRef();
  virtual ~TreeRef();
  
  TreeRef(const TreeRef& from);
  
  inline TreeRef& operator=(const TreeRef& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TreeRef& default_instance();
  
  void Swap(TreeRef* other);
  
  // implements Message ----------------------------------------------
  
  TreeRef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TreeRef& from);
  void MergeFrom(const TreeRef& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required int32 mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);
  
  // required int64 mtime = 3;
  inline bool has_mtime() const;
  inline void clear_mtime();
  static const int kMtimeFieldNumber = 3;
  inline ::google::protobuf::int64 mtime() const;
  inline void set_mtime(::google::protobuf::int64 value);
  
  // optional int32 mtime_ns = 4;
  inline bool has_mtime_ns() const;
  inline void clear_mtime_ns();
  static const int kMtimeNsFieldNumber = 4;
  inline ::google::protobuf::int32 mtime_ns() const;
  inline void set_mtime_ns(::google::protobuf::int32 value);
  
  // required int32 sha_idx = 5;
  inline bool has_sha_idx() const;
  inline void clear_sha_idx();
  static const int kShaIdxFieldNumber = 5;
  inline ::google::protobuf::int32 sha_idx() const;
  inline void set_sha_idx(::google::protobuf::int32 value);
  
  // optional bytes key = 6;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 6;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(TreeRef)
  // @@protoc_insertion_point(class_scope:Lyekka.pb.TreeRef)
 private:
  ::google::protobuf::internal::ExtensionSet _extensions_;
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::int64 mtime_;
  ::google::protobuf::int32 mtime_ns_;
  ::google::protobuf::int32 sha_idx_;
  ::std::string* key_;
  static const ::std::string _default_key_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TreeRef* default_instance_;
};
// -------------------------------------------------------------------

class Part : public ::google::protobuf::Message {
 public:
  Part();
  virtual ~Part();
  
  Part(const Part& from);
  
  inline Part& operator=(const Part& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Part& default_instance();
  
  void Swap(Part* other);
  
  // implements Message ----------------------------------------------
  
  Part* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Part& from);
  void MergeFrom(const Part& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint64 offset = 1;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 1;
  inline ::google::protobuf::uint64 offset() const;
  inline void set_offset(::google::protobuf::uint64 value);
  
  // required uint32 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);
  
  // required int32 sha_idx = 3;
  inline bool has_sha_idx() const;
  inline void clear_sha_idx();
  static const int kShaIdxFieldNumber = 3;
  inline ::google::protobuf::int32 sha_idx() const;
  inline void set_sha_idx(::google::protobuf::int32 value);
  
  // optional bytes key = 4;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 4;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
  // optional .Lyekka.pb.Compression compression = 5 [default = ZLIB];
  inline bool has_compression() const;
  inline void clear_compression();
  static const int kCompressionFieldNumber = 5;
  inline Lyekka::pb::Compression compression() const;
  inline void set_compression(Lyekka::pb::Compression value);
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Part)
  // @@protoc_insertion_point(class_scope:Lyekka.pb.Part)
 private:
  ::google::protobuf::internal::ExtensionSet _extensions_;
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint32 size_;
  ::google::protobuf::int32 sha_idx_;
  ::std::string* key_;
  static const ::std::string _default_key_;
  int compression_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Part* default_instance_;
};
// -------------------------------------------------------------------

class FileEntry : public ::google::protobuf::Message {
 public:
  FileEntry();
  virtual ~FileEntry();
  
  FileEntry(const FileEntry& from);
  
  inline FileEntry& operator=(const FileEntry& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileEntry& default_instance();
  
  void Swap(FileEntry* other);
  
  // implements Message ----------------------------------------------
  
  FileEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileEntry& from);
  void MergeFrom(const FileEntry& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required int32 mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);
  
  // required uint64 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);
  
  // required int64 mtime = 4;
  inline bool has_mtime() const;
  inline void clear_mtime();
  static const int kMtimeFieldNumber = 4;
  inline ::google::protobuf::int64 mtime() const;
  inline void set_mtime(::google::protobuf::int64 value);
  
  // optional int32 mtime_ns = 5;
  inline bool has_mtime_ns() const;
  inline void clear_mtime_ns();
  static const int kMtimeNsFieldNumber = 5;
  inline ::google::protobuf::int32 mtime_ns() const;
  inline void set_mtime_ns(::google::protobuf::int32 value);
  
  // repeated .Lyekka.pb.Part parts = 6;
  inline int parts_size() const;
  inline void clear_parts();
  static const int kPartsFieldNumber = 6;
  inline const ::Lyekka::pb::Part& parts(int index) const;
  inline ::Lyekka::pb::Part* mutable_parts(int index);
  inline ::Lyekka::pb::Part* add_parts();
  inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Part >&
      parts() const;
  inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Part >*
      mutable_parts();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.FileEntry)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int64 mtime_;
  ::google::protobuf::int32 mtime_ns_;
  ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Part > parts_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FileEntry* default_instance_;
};
// -------------------------------------------------------------------

class Tree : public ::google::protobuf::Message {
 public:
  Tree();
  virtual ~Tree();
  
  Tree(const Tree& from);
  
  inline Tree& operator=(const Tree& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tree& default_instance();
  
  void Swap(Tree* other);
  
  // implements Message ----------------------------------------------
  
  Tree* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tree& from);
  void MergeFrom(const Tree& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Lyekka.pb.TreeRef subdirs = 1;
  inline int subdirs_size() const;
  inline void clear_subdirs();
  static const int kSubdirsFieldNumber = 1;
  inline const ::Lyekka::pb::TreeRef& subdirs(int index) const;
  inline ::Lyekka::pb::TreeRef* mutable_subdirs(int index);
  inline ::Lyekka::pb::TreeRef* add_subdirs();
  inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::TreeRef >&
      subdirs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::TreeRef >*
      mutable_subdirs();
  
  // repeated .Lyekka.pb.FileEntry files = 2;
  inline int files_size() const;
  inline void clear_files();
  static const int kFilesFieldNumber = 2;
  inline const ::Lyekka::pb::FileEntry& files(int index) const;
  inline ::Lyekka::pb::FileEntry* mutable_files(int index);
  inline ::Lyekka::pb::FileEntry* add_files();
  inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::FileEntry >&
      files() const;
  inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::FileEntry >*
      mutable_files();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.Tree)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::TreeRef > subdirs_;
  ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::FileEntry > files_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Tree* default_instance_;
};
// -------------------------------------------------------------------

class Property : public ::google::protobuf::Message {
 public:
  Property();
  virtual ~Property();
  
  Property(const Property& from);
  
  inline Property& operator=(const Property& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Property& default_instance();
  
  void Swap(Property* other);
  
  // implements Message ----------------------------------------------
  
  Property* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Property& from);
  void MergeFrom(const Property& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  
  // optional string str_val = 2;
  inline bool has_str_val() const;
  inline void clear_str_val();
  static const int kStrValFieldNumber = 2;
  inline const ::std::string& str_val() const;
  inline void set_str_val(const ::std::string& value);
  inline void set_str_val(const char* value);
  inline void set_str_val(const char* value, size_t size);
  inline ::std::string* mutable_str_val();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.Property)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::std::string* str_val_;
  static const ::std::string _default_str_val_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Property* default_instance_;
};
// -------------------------------------------------------------------

class Properties : public ::google::protobuf::Message {
 public:
  Properties();
  virtual ~Properties();
  
  Properties(const Properties& from);
  
  inline Properties& operator=(const Properties& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Properties& default_instance();
  
  void Swap(Properties* other);
  
  // implements Message ----------------------------------------------
  
  Properties* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Properties& from);
  void MergeFrom(const Properties& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Lyekka.pb.Property properties = 1;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 1;
  inline const ::Lyekka::pb::Property& properties(int index) const;
  inline ::Lyekka::pb::Property* mutable_properties(int index);
  inline ::Lyekka::pb::Property* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property >*
      mutable_properties();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.Properties)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property > properties_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Properties* default_instance_;
};
// -------------------------------------------------------------------

class SecureProperties : public ::google::protobuf::Message {
 public:
  SecureProperties();
  virtual ~SecureProperties();
  
  SecureProperties(const SecureProperties& from);
  
  inline SecureProperties& operator=(const SecureProperties& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SecureProperties& default_instance();
  
  void Swap(SecureProperties* other);
  
  // implements Message ----------------------------------------------
  
  SecureProperties* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecureProperties& from);
  void MergeFrom(const SecureProperties& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Lyekka.pb.Property properties = 1;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 1;
  inline const ::Lyekka::pb::Property& properties(int index) const;
  inline ::Lyekka::pb::Property* mutable_properties(int index);
  inline ::Lyekka::pb::Property* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property >*
      mutable_properties();
  
  // optional bytes entry_point_key = 2;
  inline bool has_entry_point_key() const;
  inline void clear_entry_point_key();
  static const int kEntryPointKeyFieldNumber = 2;
  inline const ::std::string& entry_point_key() const;
  inline void set_entry_point_key(const ::std::string& value);
  inline void set_entry_point_key(const char* value);
  inline void set_entry_point_key(const void* value, size_t size);
  inline ::std::string* mutable_entry_point_key();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.SecureProperties)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property > properties_;
  ::std::string* entry_point_key_;
  static const ::std::string _default_entry_point_key_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SecureProperties* default_instance_;
};
// -------------------------------------------------------------------

class Pbkdf2Key : public ::google::protobuf::Message {
 public:
  Pbkdf2Key();
  virtual ~Pbkdf2Key();
  
  Pbkdf2Key(const Pbkdf2Key& from);
  
  inline Pbkdf2Key& operator=(const Pbkdf2Key& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pbkdf2Key& default_instance();
  
  void Swap(Pbkdf2Key* other);
  
  // implements Message ----------------------------------------------
  
  Pbkdf2Key* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pbkdf2Key& from);
  void MergeFrom(const Pbkdf2Key& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes salt = 1;
  inline bool has_salt() const;
  inline void clear_salt();
  static const int kSaltFieldNumber = 1;
  inline const ::std::string& salt() const;
  inline void set_salt(const ::std::string& value);
  inline void set_salt(const char* value);
  inline void set_salt(const void* value, size_t size);
  inline ::std::string* mutable_salt();
  
  // optional int32 iterations = 2 [default = 4096];
  inline bool has_iterations() const;
  inline void clear_iterations();
  static const int kIterationsFieldNumber = 2;
  inline ::google::protobuf::int32 iterations() const;
  inline void set_iterations(::google::protobuf::int32 value);
  
  // required bytes iv = 3;
  inline bool has_iv() const;
  inline void clear_iv();
  static const int kIvFieldNumber = 3;
  inline const ::std::string& iv() const;
  inline void set_iv(const ::std::string& value);
  inline void set_iv(const char* value);
  inline void set_iv(const void* value, size_t size);
  inline ::std::string* mutable_iv();
  
  // required bytes key = 4;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 4;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.Pbkdf2Key)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* salt_;
  static const ::std::string _default_salt_;
  ::google::protobuf::int32 iterations_;
  ::std::string* iv_;
  static const ::std::string _default_iv_;
  ::std::string* key_;
  static const ::std::string _default_key_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Pbkdf2Key* default_instance_;
};
// -------------------------------------------------------------------

class PgpKey : public ::google::protobuf::Message {
 public:
  PgpKey();
  virtual ~PgpKey();
  
  PgpKey(const PgpKey& from);
  
  inline PgpKey& operator=(const PgpKey& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PgpKey& default_instance();
  
  void Swap(PgpKey* other);
  
  // implements Message ----------------------------------------------
  
  PgpKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PgpKey& from);
  void MergeFrom(const PgpKey& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string key_id = 1;
  inline bool has_key_id() const;
  inline void clear_key_id();
  static const int kKeyIdFieldNumber = 1;
  inline const ::std::string& key_id() const;
  inline void set_key_id(const ::std::string& value);
  inline void set_key_id(const char* value);
  inline void set_key_id(const char* value, size_t size);
  inline ::std::string* mutable_key_id();
  
  // required bytes encrypted_key = 2;
  inline bool has_encrypted_key() const;
  inline void clear_encrypted_key();
  static const int kEncryptedKeyFieldNumber = 2;
  inline const ::std::string& encrypted_key() const;
  inline void set_encrypted_key(const ::std::string& value);
  inline void set_encrypted_key(const char* value);
  inline void set_encrypted_key(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_key();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.PgpKey)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_id_;
  static const ::std::string _default_key_id_;
  ::std::string* encrypted_key_;
  static const ::std::string _default_encrypted_key_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PgpKey* default_instance_;
};
// -------------------------------------------------------------------

class EncryptedProperties : public ::google::protobuf::Message {
 public:
  EncryptedProperties();
  virtual ~EncryptedProperties();
  
  EncryptedProperties(const EncryptedProperties& from);
  
  inline EncryptedProperties& operator=(const EncryptedProperties& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EncryptedProperties& default_instance();
  
  void Swap(EncryptedProperties* other);
  
  // implements Message ----------------------------------------------
  
  EncryptedProperties* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EncryptedProperties& from);
  void MergeFrom(const EncryptedProperties& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes encrypted_data = 1;
  inline bool has_encrypted_data() const;
  inline void clear_encrypted_data();
  static const int kEncryptedDataFieldNumber = 1;
  inline const ::std::string& encrypted_data() const;
  inline void set_encrypted_data(const ::std::string& value);
  inline void set_encrypted_data(const char* value);
  inline void set_encrypted_data(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_data();
  
  // required bytes iv = 2;
  inline bool has_iv() const;
  inline void clear_iv();
  static const int kIvFieldNumber = 2;
  inline const ::std::string& iv() const;
  inline void set_iv(const ::std::string& value);
  inline void set_iv(const char* value);
  inline void set_iv(const void* value, size_t size);
  inline ::std::string* mutable_iv();
  
  // optional .Lyekka.pb.Encryption algorithm = 3 [default = AES_128_CBC];
  inline bool has_algorithm() const;
  inline void clear_algorithm();
  static const int kAlgorithmFieldNumber = 3;
  inline Lyekka::pb::Encryption algorithm() const;
  inline void set_algorithm(Lyekka::pb::Encryption value);
  
  // optional .Lyekka.pb.Pbkdf2Key password_key = 4;
  inline bool has_password_key() const;
  inline void clear_password_key();
  static const int kPasswordKeyFieldNumber = 4;
  inline const ::Lyekka::pb::Pbkdf2Key& password_key() const;
  inline ::Lyekka::pb::Pbkdf2Key* mutable_password_key();
  
  // optional .Lyekka.pb.PgpKey pgp_encrypted_key = 5;
  inline bool has_pgp_encrypted_key() const;
  inline void clear_pgp_encrypted_key();
  static const int kPgpEncryptedKeyFieldNumber = 5;
  inline const ::Lyekka::pb::PgpKey& pgp_encrypted_key() const;
  inline ::Lyekka::pb::PgpKey* mutable_pgp_encrypted_key();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.EncryptedProperties)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* encrypted_data_;
  static const ::std::string _default_encrypted_data_;
  ::std::string* iv_;
  static const ::std::string _default_iv_;
  int algorithm_;
  ::Lyekka::pb::Pbkdf2Key* password_key_;
  ::Lyekka::pb::PgpKey* pgp_encrypted_key_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static EncryptedProperties* default_instance_;
};
// -------------------------------------------------------------------

class Manifest : public ::google::protobuf::Message {
 public:
  Manifest();
  virtual ~Manifest();
  
  Manifest(const Manifest& from);
  
  inline Manifest& operator=(const Manifest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Manifest& default_instance();
  
  void Swap(Manifest* other);
  
  // implements Message ----------------------------------------------
  
  Manifest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Manifest& from);
  void MergeFrom(const Manifest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Lyekka.pb.Properties properties = 1;
  inline bool has_properties() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 1;
  inline const ::Lyekka::pb::Properties& properties() const;
  inline ::Lyekka::pb::Properties* mutable_properties();
  
  // optional .Lyekka.pb.EncryptedProperties secure_properties = 2;
  inline bool has_secure_properties() const;
  inline void clear_secure_properties();
  static const int kSecurePropertiesFieldNumber = 2;
  inline const ::Lyekka::pb::EncryptedProperties& secure_properties() const;
  inline ::Lyekka::pb::EncryptedProperties* mutable_secure_properties();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.Manifest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::Lyekka::pb::Properties* properties_;
  ::Lyekka::pb::EncryptedProperties* secure_properties_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Manifest* default_instance_;
};
// -------------------------------------------------------------------

class Signature : public ::google::protobuf::Message {
 public:
  Signature();
  virtual ~Signature();
  
  Signature(const Signature& from);
  
  inline Signature& operator=(const Signature& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Signature& default_instance();
  
  void Swap(Signature* other);
  
  // implements Message ----------------------------------------------
  
  Signature* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Signature& from);
  void MergeFrom(const Signature& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes signature = 1;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 1;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.Signature)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* signature_;
  static const ::std::string _default_signature_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Signature* default_instance_;
};
// ===================================================================


// ===================================================================

// TreeRef

// required string name = 1;
inline bool TreeRef::has_name() const {
  return _has_bit(0);
}
inline void TreeRef::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& TreeRef::name() const {
  return *name_;
}
inline void TreeRef::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TreeRef::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TreeRef::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TreeRef::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required int32 mode = 2;
inline bool TreeRef::has_mode() const {
  return _has_bit(1);
}
inline void TreeRef::clear_mode() {
  mode_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 TreeRef::mode() const {
  return mode_;
}
inline void TreeRef::set_mode(::google::protobuf::int32 value) {
  _set_bit(1);
  mode_ = value;
}

// required int64 mtime = 3;
inline bool TreeRef::has_mtime() const {
  return _has_bit(2);
}
inline void TreeRef::clear_mtime() {
  mtime_ = GOOGLE_LONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::int64 TreeRef::mtime() const {
  return mtime_;
}
inline void TreeRef::set_mtime(::google::protobuf::int64 value) {
  _set_bit(2);
  mtime_ = value;
}

// optional int32 mtime_ns = 4;
inline bool TreeRef::has_mtime_ns() const {
  return _has_bit(3);
}
inline void TreeRef::clear_mtime_ns() {
  mtime_ns_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 TreeRef::mtime_ns() const {
  return mtime_ns_;
}
inline void TreeRef::set_mtime_ns(::google::protobuf::int32 value) {
  _set_bit(3);
  mtime_ns_ = value;
}

// required int32 sha_idx = 5;
inline bool TreeRef::has_sha_idx() const {
  return _has_bit(4);
}
inline void TreeRef::clear_sha_idx() {
  sha_idx_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 TreeRef::sha_idx() const {
  return sha_idx_;
}
inline void TreeRef::set_sha_idx(::google::protobuf::int32 value) {
  _set_bit(4);
  sha_idx_ = value;
}

// optional bytes key = 6;
inline bool TreeRef::has_key() const {
  return _has_bit(5);
}
inline void TreeRef::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& TreeRef::key() const {
  return *key_;
}
inline void TreeRef::set_key(const ::std::string& value) {
  _set_bit(5);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void TreeRef::set_key(const char* value) {
  _set_bit(5);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void TreeRef::set_key(const void* value, size_t size) {
  _set_bit(5);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TreeRef::mutable_key() {
  _set_bit(5);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// -------------------------------------------------------------------

// Part

// optional uint64 offset = 1;
inline bool Part::has_offset() const {
  return _has_bit(0);
}
inline void Part::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 Part::offset() const {
  return offset_;
}
inline void Part::set_offset(::google::protobuf::uint64 value) {
  _set_bit(0);
  offset_ = value;
}

// required uint32 size = 2;
inline bool Part::has_size() const {
  return _has_bit(1);
}
inline void Part::clear_size() {
  size_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 Part::size() const {
  return size_;
}
inline void Part::set_size(::google::protobuf::uint32 value) {
  _set_bit(1);
  size_ = value;
}

// required int32 sha_idx = 3;
inline bool Part::has_sha_idx() const {
  return _has_bit(2);
}
inline void Part::clear_sha_idx() {
  sha_idx_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Part::sha_idx() const {
  return sha_idx_;
}
inline void Part::set_sha_idx(::google::protobuf::int32 value) {
  _set_bit(2);
  sha_idx_ = value;
}

// optional bytes key = 4;
inline bool Part::has_key() const {
  return _has_bit(3);
}
inline void Part::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Part::key() const {
  return *key_;
}
inline void Part::set_key(const ::std::string& value) {
  _set_bit(3);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Part::set_key(const char* value) {
  _set_bit(3);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Part::set_key(const void* value, size_t size) {
  _set_bit(3);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Part::mutable_key() {
  _set_bit(3);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// optional .Lyekka.pb.Compression compression = 5 [default = ZLIB];
inline bool Part::has_compression() const {
  return _has_bit(4);
}
inline void Part::clear_compression() {
  compression_ = 0;
  _clear_bit(4);
}
inline Lyekka::pb::Compression Part::compression() const {
  return static_cast< Lyekka::pb::Compression >(compression_);
}
inline void Part::set_compression(Lyekka::pb::Compression value) {
  GOOGLE_DCHECK(Lyekka::pb::Compression_IsValid(value));
  _set_bit(4);
  compression_ = value;
}

// -------------------------------------------------------------------

// FileEntry

// required string name = 1;
inline bool FileEntry::has_name() const {
  return _has_bit(0);
}
inline void FileEntry::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FileEntry::name() const {
  return *name_;
}
inline void FileEntry::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FileEntry::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FileEntry::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileEntry::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required int32 mode = 2;
inline bool FileEntry::has_mode() const {
  return _has_bit(1);
}
inline void FileEntry::clear_mode() {
  mode_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 FileEntry::mode() const {
  return mode_;
}
inline void FileEntry::set_mode(::google::protobuf::int32 value) {
  _set_bit(1);
  mode_ = value;
}

// required uint64 size = 3;
inline bool FileEntry::has_size() const {
  return _has_bit(2);
}
inline void FileEntry::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 FileEntry::size() const {
  return size_;
}
inline void FileEntry::set_size(::google::protobuf::uint64 value) {
  _set_bit(2);
  size_ = value;
}

// required int64 mtime = 4;
inline bool FileEntry::has_mtime() const {
  return _has_bit(3);
}
inline void FileEntry::clear_mtime() {
  mtime_ = GOOGLE_LONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::int64 FileEntry::mtime() const {
  return mtime_;
}
inline void FileEntry::set_mtime(::google::protobuf::int64 value) {
  _set_bit(3);
  mtime_ = value;
}

// optional int32 mtime_ns = 5;
inline bool FileEntry::has_mtime_ns() const {
  return _has_bit(4);
}
inline void FileEntry::clear_mtime_ns() {
  mtime_ns_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 FileEntry::mtime_ns() const {
  return mtime_ns_;
}
inline void FileEntry::set_mtime_ns(::google::protobuf::int32 value) {
  _set_bit(4);
  mtime_ns_ = value;
}

// repeated .Lyekka.pb.Part parts = 6;
inline int FileEntry::parts_size() const {
  return parts_.size();
}
inline void FileEntry::clear_parts() {
  parts_.Clear();
}
inline const ::Lyekka::pb::Part& FileEntry::parts(int index) const {
  return parts_.Get(index);
}
inline ::Lyekka::pb::Part* FileEntry::mutable_parts(int index) {
  return parts_.Mutable(index);
}
inline ::Lyekka::pb::Part* FileEntry::add_parts() {
  return parts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Part >&
FileEntry::parts() const {
  return parts_;
}
inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Part >*
FileEntry::mutable_parts() {
  return &parts_;
}

// -------------------------------------------------------------------

// Tree

// repeated .Lyekka.pb.TreeRef subdirs = 1;
inline int Tree::subdirs_size() const {
  return subdirs_.size();
}
inline void Tree::clear_subdirs() {
  subdirs_.Clear();
}
inline const ::Lyekka::pb::TreeRef& Tree::subdirs(int index) const {
  return subdirs_.Get(index);
}
inline ::Lyekka::pb::TreeRef* Tree::mutable_subdirs(int index) {
  return subdirs_.Mutable(index);
}
inline ::Lyekka::pb::TreeRef* Tree::add_subdirs() {
  return subdirs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::TreeRef >&
Tree::subdirs() const {
  return subdirs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::TreeRef >*
Tree::mutable_subdirs() {
  return &subdirs_;
}

// repeated .Lyekka.pb.FileEntry files = 2;
inline int Tree::files_size() const {
  return files_.size();
}
inline void Tree::clear_files() {
  files_.Clear();
}
inline const ::Lyekka::pb::FileEntry& Tree::files(int index) const {
  return files_.Get(index);
}
inline ::Lyekka::pb::FileEntry* Tree::mutable_files(int index) {
  return files_.Mutable(index);
}
inline ::Lyekka::pb::FileEntry* Tree::add_files() {
  return files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::FileEntry >&
Tree::files() const {
  return files_;
}
inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::FileEntry >*
Tree::mutable_files() {
  return &files_;
}

// -------------------------------------------------------------------

// Property

// required string key = 1;
inline bool Property::has_key() const {
  return _has_bit(0);
}
inline void Property::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Property::key() const {
  return *key_;
}
inline void Property::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Property::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Property::set_key(const char* value, size_t size) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// optional string str_val = 2;
inline bool Property::has_str_val() const {
  return _has_bit(1);
}
inline void Property::clear_str_val() {
  if (str_val_ != &_default_str_val_) {
    str_val_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Property::str_val() const {
  return *str_val_;
}
inline void Property::set_str_val(const ::std::string& value) {
  _set_bit(1);
  if (str_val_ == &_default_str_val_) {
    str_val_ = new ::std::string;
  }
  str_val_->assign(value);
}
inline void Property::set_str_val(const char* value) {
  _set_bit(1);
  if (str_val_ == &_default_str_val_) {
    str_val_ = new ::std::string;
  }
  str_val_->assign(value);
}
inline void Property::set_str_val(const char* value, size_t size) {
  _set_bit(1);
  if (str_val_ == &_default_str_val_) {
    str_val_ = new ::std::string;
  }
  str_val_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_str_val() {
  _set_bit(1);
  if (str_val_ == &_default_str_val_) {
    str_val_ = new ::std::string;
  }
  return str_val_;
}

// -------------------------------------------------------------------

// Properties

// repeated .Lyekka.pb.Property properties = 1;
inline int Properties::properties_size() const {
  return properties_.size();
}
inline void Properties::clear_properties() {
  properties_.Clear();
}
inline const ::Lyekka::pb::Property& Properties::properties(int index) const {
  return properties_.Get(index);
}
inline ::Lyekka::pb::Property* Properties::mutable_properties(int index) {
  return properties_.Mutable(index);
}
inline ::Lyekka::pb::Property* Properties::add_properties() {
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property >&
Properties::properties() const {
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property >*
Properties::mutable_properties() {
  return &properties_;
}

// -------------------------------------------------------------------

// SecureProperties

// repeated .Lyekka.pb.Property properties = 1;
inline int SecureProperties::properties_size() const {
  return properties_.size();
}
inline void SecureProperties::clear_properties() {
  properties_.Clear();
}
inline const ::Lyekka::pb::Property& SecureProperties::properties(int index) const {
  return properties_.Get(index);
}
inline ::Lyekka::pb::Property* SecureProperties::mutable_properties(int index) {
  return properties_.Mutable(index);
}
inline ::Lyekka::pb::Property* SecureProperties::add_properties() {
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property >&
SecureProperties::properties() const {
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property >*
SecureProperties::mutable_properties() {
  return &properties_;
}

// optional bytes entry_point_key = 2;
inline bool SecureProperties::has_entry_point_key() const {
  return _has_bit(1);
}
inline void SecureProperties::clear_entry_point_key() {
  if (entry_point_key_ != &_default_entry_point_key_) {
    entry_point_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& SecureProperties::entry_point_key() const {
  return *entry_point_key_;
}
inline void SecureProperties::set_entry_point_key(const ::std::string& value) {
  _set_bit(1);
  if (entry_point_key_ == &_default_entry_point_key_) {
    entry_point_key_ = new ::std::string;
  }
  entry_point_key_->assign(value);
}
inline void SecureProperties::set_entry_point_key(const char* value) {
  _set_bit(1);
  if (entry_point_key_ == &_default_entry_point_key_) {
    entry_point_key_ = new ::std::string;
  }
  entry_point_key_->assign(value);
}
inline void SecureProperties::set_entry_point_key(const void* value, size_t size) {
  _set_bit(1);
  if (entry_point_key_ == &_default_entry_point_key_) {
    entry_point_key_ = new ::std::string;
  }
  entry_point_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecureProperties::mutable_entry_point_key() {
  _set_bit(1);
  if (entry_point_key_ == &_default_entry_point_key_) {
    entry_point_key_ = new ::std::string;
  }
  return entry_point_key_;
}

// -------------------------------------------------------------------

// Pbkdf2Key

// required bytes salt = 1;
inline bool Pbkdf2Key::has_salt() const {
  return _has_bit(0);
}
inline void Pbkdf2Key::clear_salt() {
  if (salt_ != &_default_salt_) {
    salt_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Pbkdf2Key::salt() const {
  return *salt_;
}
inline void Pbkdf2Key::set_salt(const ::std::string& value) {
  _set_bit(0);
  if (salt_ == &_default_salt_) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
}
inline void Pbkdf2Key::set_salt(const char* value) {
  _set_bit(0);
  if (salt_ == &_default_salt_) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
}
inline void Pbkdf2Key::set_salt(const void* value, size_t size) {
  _set_bit(0);
  if (salt_ == &_default_salt_) {
    salt_ = new ::std::string;
  }
  salt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Pbkdf2Key::mutable_salt() {
  _set_bit(0);
  if (salt_ == &_default_salt_) {
    salt_ = new ::std::string;
  }
  return salt_;
}

// optional int32 iterations = 2 [default = 4096];
inline bool Pbkdf2Key::has_iterations() const {
  return _has_bit(1);
}
inline void Pbkdf2Key::clear_iterations() {
  iterations_ = 4096;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Pbkdf2Key::iterations() const {
  return iterations_;
}
inline void Pbkdf2Key::set_iterations(::google::protobuf::int32 value) {
  _set_bit(1);
  iterations_ = value;
}

// required bytes iv = 3;
inline bool Pbkdf2Key::has_iv() const {
  return _has_bit(2);
}
inline void Pbkdf2Key::clear_iv() {
  if (iv_ != &_default_iv_) {
    iv_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Pbkdf2Key::iv() const {
  return *iv_;
}
inline void Pbkdf2Key::set_iv(const ::std::string& value) {
  _set_bit(2);
  if (iv_ == &_default_iv_) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void Pbkdf2Key::set_iv(const char* value) {
  _set_bit(2);
  if (iv_ == &_default_iv_) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void Pbkdf2Key::set_iv(const void* value, size_t size) {
  _set_bit(2);
  if (iv_ == &_default_iv_) {
    iv_ = new ::std::string;
  }
  iv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Pbkdf2Key::mutable_iv() {
  _set_bit(2);
  if (iv_ == &_default_iv_) {
    iv_ = new ::std::string;
  }
  return iv_;
}

// required bytes key = 4;
inline bool Pbkdf2Key::has_key() const {
  return _has_bit(3);
}
inline void Pbkdf2Key::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Pbkdf2Key::key() const {
  return *key_;
}
inline void Pbkdf2Key::set_key(const ::std::string& value) {
  _set_bit(3);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Pbkdf2Key::set_key(const char* value) {
  _set_bit(3);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Pbkdf2Key::set_key(const void* value, size_t size) {
  _set_bit(3);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Pbkdf2Key::mutable_key() {
  _set_bit(3);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// -------------------------------------------------------------------

// PgpKey

// optional string key_id = 1;
inline bool PgpKey::has_key_id() const {
  return _has_bit(0);
}
inline void PgpKey::clear_key_id() {
  if (key_id_ != &_default_key_id_) {
    key_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& PgpKey::key_id() const {
  return *key_id_;
}
inline void PgpKey::set_key_id(const ::std::string& value) {
  _set_bit(0);
  if (key_id_ == &_default_key_id_) {
    key_id_ = new ::std::string;
  }
  key_id_->assign(value);
}
inline void PgpKey::set_key_id(const char* value) {
  _set_bit(0);
  if (key_id_ == &_default_key_id_) {
    key_id_ = new ::std::string;
  }
  key_id_->assign(value);
}
inline void PgpKey::set_key_id(const char* value, size_t size) {
  _set_bit(0);
  if (key_id_ == &_default_key_id_) {
    key_id_ = new ::std::string;
  }
  key_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PgpKey::mutable_key_id() {
  _set_bit(0);
  if (key_id_ == &_default_key_id_) {
    key_id_ = new ::std::string;
  }
  return key_id_;
}

// required bytes encrypted_key = 2;
inline bool PgpKey::has_encrypted_key() const {
  return _has_bit(1);
}
inline void PgpKey::clear_encrypted_key() {
  if (encrypted_key_ != &_default_encrypted_key_) {
    encrypted_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& PgpKey::encrypted_key() const {
  return *encrypted_key_;
}
inline void PgpKey::set_encrypted_key(const ::std::string& value) {
  _set_bit(1);
  if (encrypted_key_ == &_default_encrypted_key_) {
    encrypted_key_ = new ::std::string;
  }
  encrypted_key_->assign(value);
}
inline void PgpKey::set_encrypted_key(const char* value) {
  _set_bit(1);
  if (encrypted_key_ == &_default_encrypted_key_) {
    encrypted_key_ = new ::std::string;
  }
  encrypted_key_->assign(value);
}
inline void PgpKey::set_encrypted_key(const void* value, size_t size) {
  _set_bit(1);
  if (encrypted_key_ == &_default_encrypted_key_) {
    encrypted_key_ = new ::std::string;
  }
  encrypted_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PgpKey::mutable_encrypted_key() {
  _set_bit(1);
  if (encrypted_key_ == &_default_encrypted_key_) {
    encrypted_key_ = new ::std::string;
  }
  return encrypted_key_;
}

// -------------------------------------------------------------------

// EncryptedProperties

// required bytes encrypted_data = 1;
inline bool EncryptedProperties::has_encrypted_data() const {
  return _has_bit(0);
}
inline void EncryptedProperties::clear_encrypted_data() {
  if (encrypted_data_ != &_default_encrypted_data_) {
    encrypted_data_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& EncryptedProperties::encrypted_data() const {
  return *encrypted_data_;
}
inline void EncryptedProperties::set_encrypted_data(const ::std::string& value) {
  _set_bit(0);
  if (encrypted_data_ == &_default_encrypted_data_) {
    encrypted_data_ = new ::std::string;
  }
  encrypted_data_->assign(value);
}
inline void EncryptedProperties::set_encrypted_data(const char* value) {
  _set_bit(0);
  if (encrypted_data_ == &_default_encrypted_data_) {
    encrypted_data_ = new ::std::string;
  }
  encrypted_data_->assign(value);
}
inline void EncryptedProperties::set_encrypted_data(const void* value, size_t size) {
  _set_bit(0);
  if (encrypted_data_ == &_default_encrypted_data_) {
    encrypted_data_ = new ::std::string;
  }
  encrypted_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptedProperties::mutable_encrypted_data() {
  _set_bit(0);
  if (encrypted_data_ == &_default_encrypted_data_) {
    encrypted_data_ = new ::std::string;
  }
  return encrypted_data_;
}

// required bytes iv = 2;
inline bool EncryptedProperties::has_iv() const {
  return _has_bit(1);
}
inline void EncryptedProperties::clear_iv() {
  if (iv_ != &_default_iv_) {
    iv_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& EncryptedProperties::iv() const {
  return *iv_;
}
inline void EncryptedProperties::set_iv(const ::std::string& value) {
  _set_bit(1);
  if (iv_ == &_default_iv_) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void EncryptedProperties::set_iv(const char* value) {
  _set_bit(1);
  if (iv_ == &_default_iv_) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void EncryptedProperties::set_iv(const void* value, size_t size) {
  _set_bit(1);
  if (iv_ == &_default_iv_) {
    iv_ = new ::std::string;
  }
  iv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptedProperties::mutable_iv() {
  _set_bit(1);
  if (iv_ == &_default_iv_) {
    iv_ = new ::std::string;
  }
  return iv_;
}

// optional .Lyekka.pb.Encryption algorithm = 3 [default = AES_128_CBC];
inline bool EncryptedProperties::has_algorithm() const {
  return _has_bit(2);
}
inline void EncryptedProperties::clear_algorithm() {
  algorithm_ = 1;
  _clear_bit(2);
}
inline Lyekka::pb::Encryption EncryptedProperties::algorithm() const {
  return static_cast< Lyekka::pb::Encryption >(algorithm_);
}
inline void EncryptedProperties::set_algorithm(Lyekka::pb::Encryption value) {
  GOOGLE_DCHECK(Lyekka::pb::Encryption_IsValid(value));
  _set_bit(2);
  algorithm_ = value;
}

// optional .Lyekka.pb.Pbkdf2Key password_key = 4;
inline bool EncryptedProperties::has_password_key() const {
  return _has_bit(3);
}
inline void EncryptedProperties::clear_password_key() {
  if (password_key_ != NULL) password_key_->::Lyekka::pb::Pbkdf2Key::Clear();
  _clear_bit(3);
}
inline const ::Lyekka::pb::Pbkdf2Key& EncryptedProperties::password_key() const {
  return password_key_ != NULL ? *password_key_ : *default_instance_->password_key_;
}
inline ::Lyekka::pb::Pbkdf2Key* EncryptedProperties::mutable_password_key() {
  _set_bit(3);
  if (password_key_ == NULL) password_key_ = new ::Lyekka::pb::Pbkdf2Key;
  return password_key_;
}

// optional .Lyekka.pb.PgpKey pgp_encrypted_key = 5;
inline bool EncryptedProperties::has_pgp_encrypted_key() const {
  return _has_bit(4);
}
inline void EncryptedProperties::clear_pgp_encrypted_key() {
  if (pgp_encrypted_key_ != NULL) pgp_encrypted_key_->::Lyekka::pb::PgpKey::Clear();
  _clear_bit(4);
}
inline const ::Lyekka::pb::PgpKey& EncryptedProperties::pgp_encrypted_key() const {
  return pgp_encrypted_key_ != NULL ? *pgp_encrypted_key_ : *default_instance_->pgp_encrypted_key_;
}
inline ::Lyekka::pb::PgpKey* EncryptedProperties::mutable_pgp_encrypted_key() {
  _set_bit(4);
  if (pgp_encrypted_key_ == NULL) pgp_encrypted_key_ = new ::Lyekka::pb::PgpKey;
  return pgp_encrypted_key_;
}

// -------------------------------------------------------------------

// Manifest

// optional .Lyekka.pb.Properties properties = 1;
inline bool Manifest::has_properties() const {
  return _has_bit(0);
}
inline void Manifest::clear_properties() {
  if (properties_ != NULL) properties_->::Lyekka::pb::Properties::Clear();
  _clear_bit(0);
}
inline const ::Lyekka::pb::Properties& Manifest::properties() const {
  return properties_ != NULL ? *properties_ : *default_instance_->properties_;
}
inline ::Lyekka::pb::Properties* Manifest::mutable_properties() {
  _set_bit(0);
  if (properties_ == NULL) properties_ = new ::Lyekka::pb::Properties;
  return properties_;
}

// optional .Lyekka.pb.EncryptedProperties secure_properties = 2;
inline bool Manifest::has_secure_properties() const {
  return _has_bit(1);
}
inline void Manifest::clear_secure_properties() {
  if (secure_properties_ != NULL) secure_properties_->::Lyekka::pb::EncryptedProperties::Clear();
  _clear_bit(1);
}
inline const ::Lyekka::pb::EncryptedProperties& Manifest::secure_properties() const {
  return secure_properties_ != NULL ? *secure_properties_ : *default_instance_->secure_properties_;
}
inline ::Lyekka::pb::EncryptedProperties* Manifest::mutable_secure_properties() {
  _set_bit(1);
  if (secure_properties_ == NULL) secure_properties_ = new ::Lyekka::pb::EncryptedProperties;
  return secure_properties_;
}

// -------------------------------------------------------------------

// Signature

// optional bytes signature = 1;
inline bool Signature::has_signature() const {
  return _has_bit(0);
}
inline void Signature::clear_signature() {
  if (signature_ != &_default_signature_) {
    signature_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Signature::signature() const {
  return *signature_;
}
inline void Signature::set_signature(const ::std::string& value) {
  _set_bit(0);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void Signature::set_signature(const char* value) {
  _set_bit(0);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void Signature::set_signature(const void* value, size_t size) {
  _set_bit(0);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Signature::mutable_signature() {
  _set_bit(0);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  return signature_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace Lyekka

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< Lyekka::pb::Encryption>() {
  return Lyekka::pb::Encryption_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< Lyekka::pb::Compression>() {
  return Lyekka::pb::Compression_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_lyekka_2eproto__INCLUDED

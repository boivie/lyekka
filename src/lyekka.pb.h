// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lyekka.proto

#ifndef PROTOBUF_lyekka_2eproto__INCLUDED
#define PROTOBUF_lyekka_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace Lyekka {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_lyekka_2eproto();
void protobuf_AssignDesc_lyekka_2eproto();
void protobuf_ShutdownFile_lyekka_2eproto();

class TreeRef;
class Part;
class FileEntry;
class Tree;
class Property;
class Properties;
class SecureProperties;
class Signature;
class Manifest;

enum Compression {
  GZIP = 0,
  NONE = 1
};
bool Compression_IsValid(int value);
const Compression Compression_MIN = GZIP;
const Compression Compression_MAX = NONE;
const int Compression_ARRAYSIZE = Compression_MAX + 1;

const ::google::protobuf::EnumDescriptor* Compression_descriptor();
inline const ::std::string& Compression_Name(Compression value) {
  return ::google::protobuf::internal::NameOfEnum(
    Compression_descriptor(), value);
}
inline bool Compression_Parse(
    const ::std::string& name, Compression* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Compression>(
    Compression_descriptor(), name, value);
}
// ===================================================================

class TreeRef : public ::google::protobuf::Message {
 public:
  TreeRef();
  virtual ~TreeRef();
  
  TreeRef(const TreeRef& from);
  
  inline TreeRef& operator=(const TreeRef& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TreeRef& default_instance();
  
  void Swap(TreeRef* other);
  
  // implements Message ----------------------------------------------
  
  TreeRef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TreeRef& from);
  void MergeFrom(const TreeRef& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required int32 mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);
  
  // required int64 mtime = 3;
  inline bool has_mtime() const;
  inline void clear_mtime();
  static const int kMtimeFieldNumber = 3;
  inline ::google::protobuf::int64 mtime() const;
  inline void set_mtime(::google::protobuf::int64 value);
  
  // optional int32 mtime_ns = 4;
  inline bool has_mtime_ns() const;
  inline void clear_mtime_ns();
  static const int kMtimeNsFieldNumber = 4;
  inline ::google::protobuf::int32 mtime_ns() const;
  inline void set_mtime_ns(::google::protobuf::int32 value);
  
  // required int32 sha_idx = 5;
  inline bool has_sha_idx() const;
  inline void clear_sha_idx();
  static const int kShaIdxFieldNumber = 5;
  inline ::google::protobuf::int32 sha_idx() const;
  inline void set_sha_idx(::google::protobuf::int32 value);
  
  // optional bytes key = 6;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 6;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(TreeRef)
  // @@protoc_insertion_point(class_scope:Lyekka.pb.TreeRef)
 private:
  ::google::protobuf::internal::ExtensionSet _extensions_;
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::int64 mtime_;
  ::google::protobuf::int32 mtime_ns_;
  ::google::protobuf::int32 sha_idx_;
  ::std::string* key_;
  static const ::std::string _default_key_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TreeRef* default_instance_;
};
// -------------------------------------------------------------------

class Part : public ::google::protobuf::Message {
 public:
  Part();
  virtual ~Part();
  
  Part(const Part& from);
  
  inline Part& operator=(const Part& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Part& default_instance();
  
  void Swap(Part* other);
  
  // implements Message ----------------------------------------------
  
  Part* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Part& from);
  void MergeFrom(const Part& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint64 offset = 1;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 1;
  inline ::google::protobuf::uint64 offset() const;
  inline void set_offset(::google::protobuf::uint64 value);
  
  // required uint32 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);
  
  // required int32 sha_idx = 3;
  inline bool has_sha_idx() const;
  inline void clear_sha_idx();
  static const int kShaIdxFieldNumber = 3;
  inline ::google::protobuf::int32 sha_idx() const;
  inline void set_sha_idx(::google::protobuf::int32 value);
  
  // optional bytes key = 4;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 4;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
  // optional .Lyekka.pb.Compression compression = 5 [default = GZIP];
  inline bool has_compression() const;
  inline void clear_compression();
  static const int kCompressionFieldNumber = 5;
  inline Lyekka::pb::Compression compression() const;
  inline void set_compression(Lyekka::pb::Compression value);
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Part)
  // @@protoc_insertion_point(class_scope:Lyekka.pb.Part)
 private:
  ::google::protobuf::internal::ExtensionSet _extensions_;
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint32 size_;
  ::google::protobuf::int32 sha_idx_;
  ::std::string* key_;
  static const ::std::string _default_key_;
  int compression_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Part* default_instance_;
};
// -------------------------------------------------------------------

class FileEntry : public ::google::protobuf::Message {
 public:
  FileEntry();
  virtual ~FileEntry();
  
  FileEntry(const FileEntry& from);
  
  inline FileEntry& operator=(const FileEntry& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileEntry& default_instance();
  
  void Swap(FileEntry* other);
  
  // implements Message ----------------------------------------------
  
  FileEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileEntry& from);
  void MergeFrom(const FileEntry& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required int32 mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);
  
  // required uint64 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);
  
  // required int64 mtime = 4;
  inline bool has_mtime() const;
  inline void clear_mtime();
  static const int kMtimeFieldNumber = 4;
  inline ::google::protobuf::int64 mtime() const;
  inline void set_mtime(::google::protobuf::int64 value);
  
  // optional int32 mtime_ns = 5;
  inline bool has_mtime_ns() const;
  inline void clear_mtime_ns();
  static const int kMtimeNsFieldNumber = 5;
  inline ::google::protobuf::int32 mtime_ns() const;
  inline void set_mtime_ns(::google::protobuf::int32 value);
  
  // repeated .Lyekka.pb.Part parts = 6;
  inline int parts_size() const;
  inline void clear_parts();
  static const int kPartsFieldNumber = 6;
  inline const ::Lyekka::pb::Part& parts(int index) const;
  inline ::Lyekka::pb::Part* mutable_parts(int index);
  inline ::Lyekka::pb::Part* add_parts();
  inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Part >&
      parts() const;
  inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Part >*
      mutable_parts();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.FileEntry)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int64 mtime_;
  ::google::protobuf::int32 mtime_ns_;
  ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Part > parts_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FileEntry* default_instance_;
};
// -------------------------------------------------------------------

class Tree : public ::google::protobuf::Message {
 public:
  Tree();
  virtual ~Tree();
  
  Tree(const Tree& from);
  
  inline Tree& operator=(const Tree& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tree& default_instance();
  
  void Swap(Tree* other);
  
  // implements Message ----------------------------------------------
  
  Tree* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tree& from);
  void MergeFrom(const Tree& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Lyekka.pb.TreeRef subdirs = 1;
  inline int subdirs_size() const;
  inline void clear_subdirs();
  static const int kSubdirsFieldNumber = 1;
  inline const ::Lyekka::pb::TreeRef& subdirs(int index) const;
  inline ::Lyekka::pb::TreeRef* mutable_subdirs(int index);
  inline ::Lyekka::pb::TreeRef* add_subdirs();
  inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::TreeRef >&
      subdirs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::TreeRef >*
      mutable_subdirs();
  
  // repeated .Lyekka.pb.FileEntry files = 2;
  inline int files_size() const;
  inline void clear_files();
  static const int kFilesFieldNumber = 2;
  inline const ::Lyekka::pb::FileEntry& files(int index) const;
  inline ::Lyekka::pb::FileEntry* mutable_files(int index);
  inline ::Lyekka::pb::FileEntry* add_files();
  inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::FileEntry >&
      files() const;
  inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::FileEntry >*
      mutable_files();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.Tree)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::TreeRef > subdirs_;
  ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::FileEntry > files_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Tree* default_instance_;
};
// -------------------------------------------------------------------

class Property : public ::google::protobuf::Message {
 public:
  Property();
  virtual ~Property();
  
  Property(const Property& from);
  
  inline Property& operator=(const Property& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Property& default_instance();
  
  void Swap(Property* other);
  
  // implements Message ----------------------------------------------
  
  Property* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Property& from);
  void MergeFrom(const Property& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  
  // optional string str_val = 2;
  inline bool has_str_val() const;
  inline void clear_str_val();
  static const int kStrValFieldNumber = 2;
  inline const ::std::string& str_val() const;
  inline void set_str_val(const ::std::string& value);
  inline void set_str_val(const char* value);
  inline void set_str_val(const char* value, size_t size);
  inline ::std::string* mutable_str_val();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.Property)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::std::string* str_val_;
  static const ::std::string _default_str_val_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Property* default_instance_;
};
// -------------------------------------------------------------------

class Properties : public ::google::protobuf::Message {
 public:
  Properties();
  virtual ~Properties();
  
  Properties(const Properties& from);
  
  inline Properties& operator=(const Properties& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Properties& default_instance();
  
  void Swap(Properties* other);
  
  // implements Message ----------------------------------------------
  
  Properties* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Properties& from);
  void MergeFrom(const Properties& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Lyekka.pb.Property properties = 1;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 1;
  inline const ::Lyekka::pb::Property& properties(int index) const;
  inline ::Lyekka::pb::Property* mutable_properties(int index);
  inline ::Lyekka::pb::Property* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property >*
      mutable_properties();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.Properties)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property > properties_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Properties* default_instance_;
};
// -------------------------------------------------------------------

class SecureProperties : public ::google::protobuf::Message {
 public:
  SecureProperties();
  virtual ~SecureProperties();
  
  SecureProperties(const SecureProperties& from);
  
  inline SecureProperties& operator=(const SecureProperties& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SecureProperties& default_instance();
  
  void Swap(SecureProperties* other);
  
  // implements Message ----------------------------------------------
  
  SecureProperties* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecureProperties& from);
  void MergeFrom(const SecureProperties& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Lyekka.pb.Property properties = 1;
  inline int properties_size() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 1;
  inline const ::Lyekka::pb::Property& properties(int index) const;
  inline ::Lyekka::pb::Property* mutable_properties(int index);
  inline ::Lyekka::pb::Property* add_properties();
  inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property >&
      properties() const;
  inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property >*
      mutable_properties();
  
  // optional bytes tree_key = 2;
  inline bool has_tree_key() const;
  inline void clear_tree_key();
  static const int kTreeKeyFieldNumber = 2;
  inline const ::std::string& tree_key() const;
  inline void set_tree_key(const ::std::string& value);
  inline void set_tree_key(const char* value);
  inline void set_tree_key(const void* value, size_t size);
  inline ::std::string* mutable_tree_key();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.SecureProperties)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property > properties_;
  ::std::string* tree_key_;
  static const ::std::string _default_tree_key_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SecureProperties* default_instance_;
};
// -------------------------------------------------------------------

class Signature : public ::google::protobuf::Message {
 public:
  Signature();
  virtual ~Signature();
  
  Signature(const Signature& from);
  
  inline Signature& operator=(const Signature& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Signature& default_instance();
  
  void Swap(Signature* other);
  
  // implements Message ----------------------------------------------
  
  Signature* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Signature& from);
  void MergeFrom(const Signature& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes signature = 1;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 1;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.Signature)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* signature_;
  static const ::std::string _default_signature_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Signature* default_instance_;
};
// -------------------------------------------------------------------

class Manifest : public ::google::protobuf::Message {
 public:
  Manifest();
  virtual ~Manifest();
  
  Manifest(const Manifest& from);
  
  inline Manifest& operator=(const Manifest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Manifest& default_instance();
  
  void Swap(Manifest* other);
  
  // implements Message ----------------------------------------------
  
  Manifest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Manifest& from);
  void MergeFrom(const Manifest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes tree_sha = 1;
  inline bool has_tree_sha() const;
  inline void clear_tree_sha();
  static const int kTreeShaFieldNumber = 1;
  inline const ::std::string& tree_sha() const;
  inline void set_tree_sha(const ::std::string& value);
  inline void set_tree_sha(const char* value);
  inline void set_tree_sha(const void* value, size_t size);
  inline ::std::string* mutable_tree_sha();
  
  // optional bool is_tree_encrypted = 2;
  inline bool has_is_tree_encrypted() const;
  inline void clear_is_tree_encrypted();
  static const int kIsTreeEncryptedFieldNumber = 2;
  inline bool is_tree_encrypted() const;
  inline void set_is_tree_encrypted(bool value);
  
  // optional .Lyekka.pb.Properties properties = 3;
  inline bool has_properties() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 3;
  inline const ::Lyekka::pb::Properties& properties() const;
  inline ::Lyekka::pb::Properties* mutable_properties();
  
  // optional bytes secure_properties = 4;
  inline bool has_secure_properties() const;
  inline void clear_secure_properties();
  static const int kSecurePropertiesFieldNumber = 4;
  inline const ::std::string& secure_properties() const;
  inline void set_secure_properties(const ::std::string& value);
  inline void set_secure_properties(const char* value);
  inline void set_secure_properties(const void* value, size_t size);
  inline ::std::string* mutable_secure_properties();
  
  // repeated bytes pgp_encrypted_key = 5;
  inline int pgp_encrypted_key_size() const;
  inline void clear_pgp_encrypted_key();
  static const int kPgpEncryptedKeyFieldNumber = 5;
  inline const ::std::string& pgp_encrypted_key(int index) const;
  inline ::std::string* mutable_pgp_encrypted_key(int index);
  inline void set_pgp_encrypted_key(int index, const ::std::string& value);
  inline void set_pgp_encrypted_key(int index, const char* value);
  inline void set_pgp_encrypted_key(int index, const void* value, size_t size);
  inline ::std::string* add_pgp_encrypted_key();
  inline void add_pgp_encrypted_key(const ::std::string& value);
  inline void add_pgp_encrypted_key(const char* value);
  inline void add_pgp_encrypted_key(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& pgp_encrypted_key() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pgp_encrypted_key();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.Manifest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* tree_sha_;
  static const ::std::string _default_tree_sha_;
  bool is_tree_encrypted_;
  ::Lyekka::pb::Properties* properties_;
  ::std::string* secure_properties_;
  static const ::std::string _default_secure_properties_;
  ::google::protobuf::RepeatedPtrField< ::std::string> pgp_encrypted_key_;
  friend void  protobuf_AddDesc_lyekka_2eproto();
  friend void protobuf_AssignDesc_lyekka_2eproto();
  friend void protobuf_ShutdownFile_lyekka_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Manifest* default_instance_;
};
// ===================================================================


// ===================================================================

// TreeRef

// required string name = 1;
inline bool TreeRef::has_name() const {
  return _has_bit(0);
}
inline void TreeRef::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& TreeRef::name() const {
  return *name_;
}
inline void TreeRef::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TreeRef::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TreeRef::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TreeRef::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required int32 mode = 2;
inline bool TreeRef::has_mode() const {
  return _has_bit(1);
}
inline void TreeRef::clear_mode() {
  mode_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 TreeRef::mode() const {
  return mode_;
}
inline void TreeRef::set_mode(::google::protobuf::int32 value) {
  _set_bit(1);
  mode_ = value;
}

// required int64 mtime = 3;
inline bool TreeRef::has_mtime() const {
  return _has_bit(2);
}
inline void TreeRef::clear_mtime() {
  mtime_ = GOOGLE_LONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::int64 TreeRef::mtime() const {
  return mtime_;
}
inline void TreeRef::set_mtime(::google::protobuf::int64 value) {
  _set_bit(2);
  mtime_ = value;
}

// optional int32 mtime_ns = 4;
inline bool TreeRef::has_mtime_ns() const {
  return _has_bit(3);
}
inline void TreeRef::clear_mtime_ns() {
  mtime_ns_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 TreeRef::mtime_ns() const {
  return mtime_ns_;
}
inline void TreeRef::set_mtime_ns(::google::protobuf::int32 value) {
  _set_bit(3);
  mtime_ns_ = value;
}

// required int32 sha_idx = 5;
inline bool TreeRef::has_sha_idx() const {
  return _has_bit(4);
}
inline void TreeRef::clear_sha_idx() {
  sha_idx_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 TreeRef::sha_idx() const {
  return sha_idx_;
}
inline void TreeRef::set_sha_idx(::google::protobuf::int32 value) {
  _set_bit(4);
  sha_idx_ = value;
}

// optional bytes key = 6;
inline bool TreeRef::has_key() const {
  return _has_bit(5);
}
inline void TreeRef::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& TreeRef::key() const {
  return *key_;
}
inline void TreeRef::set_key(const ::std::string& value) {
  _set_bit(5);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void TreeRef::set_key(const char* value) {
  _set_bit(5);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void TreeRef::set_key(const void* value, size_t size) {
  _set_bit(5);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TreeRef::mutable_key() {
  _set_bit(5);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// -------------------------------------------------------------------

// Part

// optional uint64 offset = 1;
inline bool Part::has_offset() const {
  return _has_bit(0);
}
inline void Part::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 Part::offset() const {
  return offset_;
}
inline void Part::set_offset(::google::protobuf::uint64 value) {
  _set_bit(0);
  offset_ = value;
}

// required uint32 size = 2;
inline bool Part::has_size() const {
  return _has_bit(1);
}
inline void Part::clear_size() {
  size_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 Part::size() const {
  return size_;
}
inline void Part::set_size(::google::protobuf::uint32 value) {
  _set_bit(1);
  size_ = value;
}

// required int32 sha_idx = 3;
inline bool Part::has_sha_idx() const {
  return _has_bit(2);
}
inline void Part::clear_sha_idx() {
  sha_idx_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Part::sha_idx() const {
  return sha_idx_;
}
inline void Part::set_sha_idx(::google::protobuf::int32 value) {
  _set_bit(2);
  sha_idx_ = value;
}

// optional bytes key = 4;
inline bool Part::has_key() const {
  return _has_bit(3);
}
inline void Part::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Part::key() const {
  return *key_;
}
inline void Part::set_key(const ::std::string& value) {
  _set_bit(3);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Part::set_key(const char* value) {
  _set_bit(3);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Part::set_key(const void* value, size_t size) {
  _set_bit(3);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Part::mutable_key() {
  _set_bit(3);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// optional .Lyekka.pb.Compression compression = 5 [default = GZIP];
inline bool Part::has_compression() const {
  return _has_bit(4);
}
inline void Part::clear_compression() {
  compression_ = 0;
  _clear_bit(4);
}
inline Lyekka::pb::Compression Part::compression() const {
  return static_cast< Lyekka::pb::Compression >(compression_);
}
inline void Part::set_compression(Lyekka::pb::Compression value) {
  GOOGLE_DCHECK(Lyekka::pb::Compression_IsValid(value));
  _set_bit(4);
  compression_ = value;
}

// -------------------------------------------------------------------

// FileEntry

// required string name = 1;
inline bool FileEntry::has_name() const {
  return _has_bit(0);
}
inline void FileEntry::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FileEntry::name() const {
  return *name_;
}
inline void FileEntry::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FileEntry::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FileEntry::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileEntry::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required int32 mode = 2;
inline bool FileEntry::has_mode() const {
  return _has_bit(1);
}
inline void FileEntry::clear_mode() {
  mode_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 FileEntry::mode() const {
  return mode_;
}
inline void FileEntry::set_mode(::google::protobuf::int32 value) {
  _set_bit(1);
  mode_ = value;
}

// required uint64 size = 3;
inline bool FileEntry::has_size() const {
  return _has_bit(2);
}
inline void FileEntry::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 FileEntry::size() const {
  return size_;
}
inline void FileEntry::set_size(::google::protobuf::uint64 value) {
  _set_bit(2);
  size_ = value;
}

// required int64 mtime = 4;
inline bool FileEntry::has_mtime() const {
  return _has_bit(3);
}
inline void FileEntry::clear_mtime() {
  mtime_ = GOOGLE_LONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::int64 FileEntry::mtime() const {
  return mtime_;
}
inline void FileEntry::set_mtime(::google::protobuf::int64 value) {
  _set_bit(3);
  mtime_ = value;
}

// optional int32 mtime_ns = 5;
inline bool FileEntry::has_mtime_ns() const {
  return _has_bit(4);
}
inline void FileEntry::clear_mtime_ns() {
  mtime_ns_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 FileEntry::mtime_ns() const {
  return mtime_ns_;
}
inline void FileEntry::set_mtime_ns(::google::protobuf::int32 value) {
  _set_bit(4);
  mtime_ns_ = value;
}

// repeated .Lyekka.pb.Part parts = 6;
inline int FileEntry::parts_size() const {
  return parts_.size();
}
inline void FileEntry::clear_parts() {
  parts_.Clear();
}
inline const ::Lyekka::pb::Part& FileEntry::parts(int index) const {
  return parts_.Get(index);
}
inline ::Lyekka::pb::Part* FileEntry::mutable_parts(int index) {
  return parts_.Mutable(index);
}
inline ::Lyekka::pb::Part* FileEntry::add_parts() {
  return parts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Part >&
FileEntry::parts() const {
  return parts_;
}
inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Part >*
FileEntry::mutable_parts() {
  return &parts_;
}

// -------------------------------------------------------------------

// Tree

// repeated .Lyekka.pb.TreeRef subdirs = 1;
inline int Tree::subdirs_size() const {
  return subdirs_.size();
}
inline void Tree::clear_subdirs() {
  subdirs_.Clear();
}
inline const ::Lyekka::pb::TreeRef& Tree::subdirs(int index) const {
  return subdirs_.Get(index);
}
inline ::Lyekka::pb::TreeRef* Tree::mutable_subdirs(int index) {
  return subdirs_.Mutable(index);
}
inline ::Lyekka::pb::TreeRef* Tree::add_subdirs() {
  return subdirs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::TreeRef >&
Tree::subdirs() const {
  return subdirs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::TreeRef >*
Tree::mutable_subdirs() {
  return &subdirs_;
}

// repeated .Lyekka.pb.FileEntry files = 2;
inline int Tree::files_size() const {
  return files_.size();
}
inline void Tree::clear_files() {
  files_.Clear();
}
inline const ::Lyekka::pb::FileEntry& Tree::files(int index) const {
  return files_.Get(index);
}
inline ::Lyekka::pb::FileEntry* Tree::mutable_files(int index) {
  return files_.Mutable(index);
}
inline ::Lyekka::pb::FileEntry* Tree::add_files() {
  return files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::FileEntry >&
Tree::files() const {
  return files_;
}
inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::FileEntry >*
Tree::mutable_files() {
  return &files_;
}

// -------------------------------------------------------------------

// Property

// required string key = 1;
inline bool Property::has_key() const {
  return _has_bit(0);
}
inline void Property::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Property::key() const {
  return *key_;
}
inline void Property::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Property::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Property::set_key(const char* value, size_t size) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// optional string str_val = 2;
inline bool Property::has_str_val() const {
  return _has_bit(1);
}
inline void Property::clear_str_val() {
  if (str_val_ != &_default_str_val_) {
    str_val_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Property::str_val() const {
  return *str_val_;
}
inline void Property::set_str_val(const ::std::string& value) {
  _set_bit(1);
  if (str_val_ == &_default_str_val_) {
    str_val_ = new ::std::string;
  }
  str_val_->assign(value);
}
inline void Property::set_str_val(const char* value) {
  _set_bit(1);
  if (str_val_ == &_default_str_val_) {
    str_val_ = new ::std::string;
  }
  str_val_->assign(value);
}
inline void Property::set_str_val(const char* value, size_t size) {
  _set_bit(1);
  if (str_val_ == &_default_str_val_) {
    str_val_ = new ::std::string;
  }
  str_val_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_str_val() {
  _set_bit(1);
  if (str_val_ == &_default_str_val_) {
    str_val_ = new ::std::string;
  }
  return str_val_;
}

// -------------------------------------------------------------------

// Properties

// repeated .Lyekka.pb.Property properties = 1;
inline int Properties::properties_size() const {
  return properties_.size();
}
inline void Properties::clear_properties() {
  properties_.Clear();
}
inline const ::Lyekka::pb::Property& Properties::properties(int index) const {
  return properties_.Get(index);
}
inline ::Lyekka::pb::Property* Properties::mutable_properties(int index) {
  return properties_.Mutable(index);
}
inline ::Lyekka::pb::Property* Properties::add_properties() {
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property >&
Properties::properties() const {
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property >*
Properties::mutable_properties() {
  return &properties_;
}

// -------------------------------------------------------------------

// SecureProperties

// repeated .Lyekka.pb.Property properties = 1;
inline int SecureProperties::properties_size() const {
  return properties_.size();
}
inline void SecureProperties::clear_properties() {
  properties_.Clear();
}
inline const ::Lyekka::pb::Property& SecureProperties::properties(int index) const {
  return properties_.Get(index);
}
inline ::Lyekka::pb::Property* SecureProperties::mutable_properties(int index) {
  return properties_.Mutable(index);
}
inline ::Lyekka::pb::Property* SecureProperties::add_properties() {
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property >&
SecureProperties::properties() const {
  return properties_;
}
inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Property >*
SecureProperties::mutable_properties() {
  return &properties_;
}

// optional bytes tree_key = 2;
inline bool SecureProperties::has_tree_key() const {
  return _has_bit(1);
}
inline void SecureProperties::clear_tree_key() {
  if (tree_key_ != &_default_tree_key_) {
    tree_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& SecureProperties::tree_key() const {
  return *tree_key_;
}
inline void SecureProperties::set_tree_key(const ::std::string& value) {
  _set_bit(1);
  if (tree_key_ == &_default_tree_key_) {
    tree_key_ = new ::std::string;
  }
  tree_key_->assign(value);
}
inline void SecureProperties::set_tree_key(const char* value) {
  _set_bit(1);
  if (tree_key_ == &_default_tree_key_) {
    tree_key_ = new ::std::string;
  }
  tree_key_->assign(value);
}
inline void SecureProperties::set_tree_key(const void* value, size_t size) {
  _set_bit(1);
  if (tree_key_ == &_default_tree_key_) {
    tree_key_ = new ::std::string;
  }
  tree_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecureProperties::mutable_tree_key() {
  _set_bit(1);
  if (tree_key_ == &_default_tree_key_) {
    tree_key_ = new ::std::string;
  }
  return tree_key_;
}

// -------------------------------------------------------------------

// Signature

// optional bytes signature = 1;
inline bool Signature::has_signature() const {
  return _has_bit(0);
}
inline void Signature::clear_signature() {
  if (signature_ != &_default_signature_) {
    signature_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Signature::signature() const {
  return *signature_;
}
inline void Signature::set_signature(const ::std::string& value) {
  _set_bit(0);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void Signature::set_signature(const char* value) {
  _set_bit(0);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void Signature::set_signature(const void* value, size_t size) {
  _set_bit(0);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Signature::mutable_signature() {
  _set_bit(0);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  return signature_;
}

// -------------------------------------------------------------------

// Manifest

// optional bytes tree_sha = 1;
inline bool Manifest::has_tree_sha() const {
  return _has_bit(0);
}
inline void Manifest::clear_tree_sha() {
  if (tree_sha_ != &_default_tree_sha_) {
    tree_sha_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Manifest::tree_sha() const {
  return *tree_sha_;
}
inline void Manifest::set_tree_sha(const ::std::string& value) {
  _set_bit(0);
  if (tree_sha_ == &_default_tree_sha_) {
    tree_sha_ = new ::std::string;
  }
  tree_sha_->assign(value);
}
inline void Manifest::set_tree_sha(const char* value) {
  _set_bit(0);
  if (tree_sha_ == &_default_tree_sha_) {
    tree_sha_ = new ::std::string;
  }
  tree_sha_->assign(value);
}
inline void Manifest::set_tree_sha(const void* value, size_t size) {
  _set_bit(0);
  if (tree_sha_ == &_default_tree_sha_) {
    tree_sha_ = new ::std::string;
  }
  tree_sha_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Manifest::mutable_tree_sha() {
  _set_bit(0);
  if (tree_sha_ == &_default_tree_sha_) {
    tree_sha_ = new ::std::string;
  }
  return tree_sha_;
}

// optional bool is_tree_encrypted = 2;
inline bool Manifest::has_is_tree_encrypted() const {
  return _has_bit(1);
}
inline void Manifest::clear_is_tree_encrypted() {
  is_tree_encrypted_ = false;
  _clear_bit(1);
}
inline bool Manifest::is_tree_encrypted() const {
  return is_tree_encrypted_;
}
inline void Manifest::set_is_tree_encrypted(bool value) {
  _set_bit(1);
  is_tree_encrypted_ = value;
}

// optional .Lyekka.pb.Properties properties = 3;
inline bool Manifest::has_properties() const {
  return _has_bit(2);
}
inline void Manifest::clear_properties() {
  if (properties_ != NULL) properties_->::Lyekka::pb::Properties::Clear();
  _clear_bit(2);
}
inline const ::Lyekka::pb::Properties& Manifest::properties() const {
  return properties_ != NULL ? *properties_ : *default_instance_->properties_;
}
inline ::Lyekka::pb::Properties* Manifest::mutable_properties() {
  _set_bit(2);
  if (properties_ == NULL) properties_ = new ::Lyekka::pb::Properties;
  return properties_;
}

// optional bytes secure_properties = 4;
inline bool Manifest::has_secure_properties() const {
  return _has_bit(3);
}
inline void Manifest::clear_secure_properties() {
  if (secure_properties_ != &_default_secure_properties_) {
    secure_properties_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Manifest::secure_properties() const {
  return *secure_properties_;
}
inline void Manifest::set_secure_properties(const ::std::string& value) {
  _set_bit(3);
  if (secure_properties_ == &_default_secure_properties_) {
    secure_properties_ = new ::std::string;
  }
  secure_properties_->assign(value);
}
inline void Manifest::set_secure_properties(const char* value) {
  _set_bit(3);
  if (secure_properties_ == &_default_secure_properties_) {
    secure_properties_ = new ::std::string;
  }
  secure_properties_->assign(value);
}
inline void Manifest::set_secure_properties(const void* value, size_t size) {
  _set_bit(3);
  if (secure_properties_ == &_default_secure_properties_) {
    secure_properties_ = new ::std::string;
  }
  secure_properties_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Manifest::mutable_secure_properties() {
  _set_bit(3);
  if (secure_properties_ == &_default_secure_properties_) {
    secure_properties_ = new ::std::string;
  }
  return secure_properties_;
}

// repeated bytes pgp_encrypted_key = 5;
inline int Manifest::pgp_encrypted_key_size() const {
  return pgp_encrypted_key_.size();
}
inline void Manifest::clear_pgp_encrypted_key() {
  pgp_encrypted_key_.Clear();
}
inline const ::std::string& Manifest::pgp_encrypted_key(int index) const {
  return pgp_encrypted_key_.Get(index);
}
inline ::std::string* Manifest::mutable_pgp_encrypted_key(int index) {
  return pgp_encrypted_key_.Mutable(index);
}
inline void Manifest::set_pgp_encrypted_key(int index, const ::std::string& value) {
  pgp_encrypted_key_.Mutable(index)->assign(value);
}
inline void Manifest::set_pgp_encrypted_key(int index, const char* value) {
  pgp_encrypted_key_.Mutable(index)->assign(value);
}
inline void Manifest::set_pgp_encrypted_key(int index, const void* value, size_t size) {
  pgp_encrypted_key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Manifest::add_pgp_encrypted_key() {
  return pgp_encrypted_key_.Add();
}
inline void Manifest::add_pgp_encrypted_key(const ::std::string& value) {
  pgp_encrypted_key_.Add()->assign(value);
}
inline void Manifest::add_pgp_encrypted_key(const char* value) {
  pgp_encrypted_key_.Add()->assign(value);
}
inline void Manifest::add_pgp_encrypted_key(const void* value, size_t size) {
  pgp_encrypted_key_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Manifest::pgp_encrypted_key() const {
  return pgp_encrypted_key_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Manifest::mutable_pgp_encrypted_key() {
  return &pgp_encrypted_key_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace Lyekka

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< Lyekka::pb::Compression>() {
  return Lyekka::pb::Compression_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_lyekka_2eproto__INCLUDED

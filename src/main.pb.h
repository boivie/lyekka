// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: main.proto

#ifndef PROTOBUF_main_2eproto__INCLUDED
#define PROTOBUF_main_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace Lyekka {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_main_2eproto();
void protobuf_AssignDesc_main_2eproto();
void protobuf_ShutdownFile_main_2eproto();

class Chunk;
class TreeRef;
class FileEntry;
class Tree;
class Index;

// ===================================================================

class Chunk : public ::google::protobuf::Message {
 public:
  Chunk();
  virtual ~Chunk();
  
  Chunk(const Chunk& from);
  
  inline Chunk& operator=(const Chunk& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Chunk& default_instance();
  
  void Swap(Chunk* other);
  
  // implements Message ----------------------------------------------
  
  Chunk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Chunk& from);
  void MergeFrom(const Chunk& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes sha = 1;
  inline bool has_sha() const;
  inline void clear_sha();
  static const int kShaFieldNumber = 1;
  inline const ::std::string& sha() const;
  inline void set_sha(const ::std::string& value);
  inline void set_sha(const char* value);
  inline void set_sha(const void* value, size_t size);
  inline ::std::string* mutable_sha();
  
  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
  // optional uint64 offset = 3;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::uint64 offset() const;
  inline void set_offset(::google::protobuf::uint64 value);
  
  // required int32 size = 4;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.Chunk)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* sha_;
  static const ::std::string _default_sha_;
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::int32 size_;
  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Chunk* default_instance_;
};
// -------------------------------------------------------------------

class TreeRef : public ::google::protobuf::Message {
 public:
  TreeRef();
  virtual ~TreeRef();
  
  TreeRef(const TreeRef& from);
  
  inline TreeRef& operator=(const TreeRef& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TreeRef& default_instance();
  
  void Swap(TreeRef* other);
  
  // implements Message ----------------------------------------------
  
  TreeRef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TreeRef& from);
  void MergeFrom(const TreeRef& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required int32 mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);
  
  // required int64 mtime = 3;
  inline bool has_mtime() const;
  inline void clear_mtime();
  static const int kMtimeFieldNumber = 3;
  inline ::google::protobuf::int64 mtime() const;
  inline void set_mtime(::google::protobuf::int64 value);
  
  // required int64 ctime = 4;
  inline bool has_ctime() const;
  inline void clear_ctime();
  static const int kCtimeFieldNumber = 4;
  inline ::google::protobuf::int64 ctime() const;
  inline void set_ctime(::google::protobuf::int64 value);
  
  // required .Lyekka.pb.Chunk chunk = 5;
  inline bool has_chunk() const;
  inline void clear_chunk();
  static const int kChunkFieldNumber = 5;
  inline const ::Lyekka::pb::Chunk& chunk() const;
  inline ::Lyekka::pb::Chunk* mutable_chunk();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.TreeRef)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::int64 mtime_;
  ::google::protobuf::int64 ctime_;
  ::Lyekka::pb::Chunk* chunk_;
  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TreeRef* default_instance_;
};
// -------------------------------------------------------------------

class FileEntry : public ::google::protobuf::Message {
 public:
  FileEntry();
  virtual ~FileEntry();
  
  FileEntry(const FileEntry& from);
  
  inline FileEntry& operator=(const FileEntry& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileEntry& default_instance();
  
  void Swap(FileEntry* other);
  
  // implements Message ----------------------------------------------
  
  FileEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileEntry& from);
  void MergeFrom(const FileEntry& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required int32 mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);
  
  // required uint64 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);
  
  // required int64 mtime = 4;
  inline bool has_mtime() const;
  inline void clear_mtime();
  static const int kMtimeFieldNumber = 4;
  inline ::google::protobuf::int64 mtime() const;
  inline void set_mtime(::google::protobuf::int64 value);
  
  // required int64 ctime = 5;
  inline bool has_ctime() const;
  inline void clear_ctime();
  static const int kCtimeFieldNumber = 5;
  inline ::google::protobuf::int64 ctime() const;
  inline void set_ctime(::google::protobuf::int64 value);
  
  // repeated .Lyekka.pb.Chunk chunks = 6;
  inline int chunks_size() const;
  inline void clear_chunks();
  static const int kChunksFieldNumber = 6;
  inline const ::Lyekka::pb::Chunk& chunks(int index) const;
  inline ::Lyekka::pb::Chunk* mutable_chunks(int index);
  inline ::Lyekka::pb::Chunk* add_chunks();
  inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Chunk >&
      chunks() const;
  inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Chunk >*
      mutable_chunks();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.FileEntry)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int64 mtime_;
  ::google::protobuf::int64 ctime_;
  ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Chunk > chunks_;
  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FileEntry* default_instance_;
};
// -------------------------------------------------------------------

class Tree : public ::google::protobuf::Message {
 public:
  Tree();
  virtual ~Tree();
  
  Tree(const Tree& from);
  
  inline Tree& operator=(const Tree& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tree& default_instance();
  
  void Swap(Tree* other);
  
  // implements Message ----------------------------------------------
  
  Tree* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tree& from);
  void MergeFrom(const Tree& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Lyekka.pb.TreeRef subdirs = 1;
  inline int subdirs_size() const;
  inline void clear_subdirs();
  static const int kSubdirsFieldNumber = 1;
  inline const ::Lyekka::pb::TreeRef& subdirs(int index) const;
  inline ::Lyekka::pb::TreeRef* mutable_subdirs(int index);
  inline ::Lyekka::pb::TreeRef* add_subdirs();
  inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::TreeRef >&
      subdirs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::TreeRef >*
      mutable_subdirs();
  
  // repeated .Lyekka.pb.FileEntry files = 2;
  inline int files_size() const;
  inline void clear_files();
  static const int kFilesFieldNumber = 2;
  inline const ::Lyekka::pb::FileEntry& files(int index) const;
  inline ::Lyekka::pb::FileEntry* mutable_files(int index);
  inline ::Lyekka::pb::FileEntry* add_files();
  inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::FileEntry >&
      files() const;
  inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::FileEntry >*
      mutable_files();
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.Tree)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::TreeRef > subdirs_;
  ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::FileEntry > files_;
  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Tree* default_instance_;
};
// -------------------------------------------------------------------

class Index : public ::google::protobuf::Message {
 public:
  Index();
  virtual ~Index();
  
  Index(const Index& from);
  
  inline Index& operator=(const Index& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Index& default_instance();
  
  void Swap(Index* other);
  
  // implements Message ----------------------------------------------
  
  Index* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Index& from);
  void MergeFrom(const Index& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 date = 1;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 1;
  inline ::google::protobuf::int64 date() const;
  inline void set_date(::google::protobuf::int64 value);
  
  // required string source = 2;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 2;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  
  // required bool complete = 3;
  inline bool has_complete() const;
  inline void clear_complete();
  static const int kCompleteFieldNumber = 3;
  inline bool complete() const;
  inline void set_complete(bool value);
  
  // @@protoc_insertion_point(class_scope:Lyekka.pb.Index)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int64 date_;
  ::std::string* source_;
  static const ::std::string _default_source_;
  bool complete_;
  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Index* default_instance_;
};
// ===================================================================


// ===================================================================

// Chunk

// required bytes sha = 1;
inline bool Chunk::has_sha() const {
  return _has_bit(0);
}
inline void Chunk::clear_sha() {
  if (sha_ != &_default_sha_) {
    sha_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Chunk::sha() const {
  return *sha_;
}
inline void Chunk::set_sha(const ::std::string& value) {
  _set_bit(0);
  if (sha_ == &_default_sha_) {
    sha_ = new ::std::string;
  }
  sha_->assign(value);
}
inline void Chunk::set_sha(const char* value) {
  _set_bit(0);
  if (sha_ == &_default_sha_) {
    sha_ = new ::std::string;
  }
  sha_->assign(value);
}
inline void Chunk::set_sha(const void* value, size_t size) {
  _set_bit(0);
  if (sha_ == &_default_sha_) {
    sha_ = new ::std::string;
  }
  sha_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chunk::mutable_sha() {
  _set_bit(0);
  if (sha_ == &_default_sha_) {
    sha_ = new ::std::string;
  }
  return sha_;
}

// required bytes key = 2;
inline bool Chunk::has_key() const {
  return _has_bit(1);
}
inline void Chunk::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Chunk::key() const {
  return *key_;
}
inline void Chunk::set_key(const ::std::string& value) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Chunk::set_key(const char* value) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Chunk::set_key(const void* value, size_t size) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chunk::mutable_key() {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// optional uint64 offset = 3;
inline bool Chunk::has_offset() const {
  return _has_bit(2);
}
inline void Chunk::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 Chunk::offset() const {
  return offset_;
}
inline void Chunk::set_offset(::google::protobuf::uint64 value) {
  _set_bit(2);
  offset_ = value;
}

// required int32 size = 4;
inline bool Chunk::has_size() const {
  return _has_bit(3);
}
inline void Chunk::clear_size() {
  size_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 Chunk::size() const {
  return size_;
}
inline void Chunk::set_size(::google::protobuf::int32 value) {
  _set_bit(3);
  size_ = value;
}

// -------------------------------------------------------------------

// TreeRef

// required string name = 1;
inline bool TreeRef::has_name() const {
  return _has_bit(0);
}
inline void TreeRef::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& TreeRef::name() const {
  return *name_;
}
inline void TreeRef::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TreeRef::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TreeRef::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TreeRef::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required int32 mode = 2;
inline bool TreeRef::has_mode() const {
  return _has_bit(1);
}
inline void TreeRef::clear_mode() {
  mode_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 TreeRef::mode() const {
  return mode_;
}
inline void TreeRef::set_mode(::google::protobuf::int32 value) {
  _set_bit(1);
  mode_ = value;
}

// required int64 mtime = 3;
inline bool TreeRef::has_mtime() const {
  return _has_bit(2);
}
inline void TreeRef::clear_mtime() {
  mtime_ = GOOGLE_LONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::int64 TreeRef::mtime() const {
  return mtime_;
}
inline void TreeRef::set_mtime(::google::protobuf::int64 value) {
  _set_bit(2);
  mtime_ = value;
}

// required int64 ctime = 4;
inline bool TreeRef::has_ctime() const {
  return _has_bit(3);
}
inline void TreeRef::clear_ctime() {
  ctime_ = GOOGLE_LONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::int64 TreeRef::ctime() const {
  return ctime_;
}
inline void TreeRef::set_ctime(::google::protobuf::int64 value) {
  _set_bit(3);
  ctime_ = value;
}

// required .Lyekka.pb.Chunk chunk = 5;
inline bool TreeRef::has_chunk() const {
  return _has_bit(4);
}
inline void TreeRef::clear_chunk() {
  if (chunk_ != NULL) chunk_->::Lyekka::pb::Chunk::Clear();
  _clear_bit(4);
}
inline const ::Lyekka::pb::Chunk& TreeRef::chunk() const {
  return chunk_ != NULL ? *chunk_ : *default_instance_->chunk_;
}
inline ::Lyekka::pb::Chunk* TreeRef::mutable_chunk() {
  _set_bit(4);
  if (chunk_ == NULL) chunk_ = new ::Lyekka::pb::Chunk;
  return chunk_;
}

// -------------------------------------------------------------------

// FileEntry

// required string name = 1;
inline bool FileEntry::has_name() const {
  return _has_bit(0);
}
inline void FileEntry::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FileEntry::name() const {
  return *name_;
}
inline void FileEntry::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FileEntry::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FileEntry::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileEntry::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required int32 mode = 2;
inline bool FileEntry::has_mode() const {
  return _has_bit(1);
}
inline void FileEntry::clear_mode() {
  mode_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 FileEntry::mode() const {
  return mode_;
}
inline void FileEntry::set_mode(::google::protobuf::int32 value) {
  _set_bit(1);
  mode_ = value;
}

// required uint64 size = 3;
inline bool FileEntry::has_size() const {
  return _has_bit(2);
}
inline void FileEntry::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 FileEntry::size() const {
  return size_;
}
inline void FileEntry::set_size(::google::protobuf::uint64 value) {
  _set_bit(2);
  size_ = value;
}

// required int64 mtime = 4;
inline bool FileEntry::has_mtime() const {
  return _has_bit(3);
}
inline void FileEntry::clear_mtime() {
  mtime_ = GOOGLE_LONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::int64 FileEntry::mtime() const {
  return mtime_;
}
inline void FileEntry::set_mtime(::google::protobuf::int64 value) {
  _set_bit(3);
  mtime_ = value;
}

// required int64 ctime = 5;
inline bool FileEntry::has_ctime() const {
  return _has_bit(4);
}
inline void FileEntry::clear_ctime() {
  ctime_ = GOOGLE_LONGLONG(0);
  _clear_bit(4);
}
inline ::google::protobuf::int64 FileEntry::ctime() const {
  return ctime_;
}
inline void FileEntry::set_ctime(::google::protobuf::int64 value) {
  _set_bit(4);
  ctime_ = value;
}

// repeated .Lyekka.pb.Chunk chunks = 6;
inline int FileEntry::chunks_size() const {
  return chunks_.size();
}
inline void FileEntry::clear_chunks() {
  chunks_.Clear();
}
inline const ::Lyekka::pb::Chunk& FileEntry::chunks(int index) const {
  return chunks_.Get(index);
}
inline ::Lyekka::pb::Chunk* FileEntry::mutable_chunks(int index) {
  return chunks_.Mutable(index);
}
inline ::Lyekka::pb::Chunk* FileEntry::add_chunks() {
  return chunks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Chunk >&
FileEntry::chunks() const {
  return chunks_;
}
inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::Chunk >*
FileEntry::mutable_chunks() {
  return &chunks_;
}

// -------------------------------------------------------------------

// Tree

// repeated .Lyekka.pb.TreeRef subdirs = 1;
inline int Tree::subdirs_size() const {
  return subdirs_.size();
}
inline void Tree::clear_subdirs() {
  subdirs_.Clear();
}
inline const ::Lyekka::pb::TreeRef& Tree::subdirs(int index) const {
  return subdirs_.Get(index);
}
inline ::Lyekka::pb::TreeRef* Tree::mutable_subdirs(int index) {
  return subdirs_.Mutable(index);
}
inline ::Lyekka::pb::TreeRef* Tree::add_subdirs() {
  return subdirs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::TreeRef >&
Tree::subdirs() const {
  return subdirs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::TreeRef >*
Tree::mutable_subdirs() {
  return &subdirs_;
}

// repeated .Lyekka.pb.FileEntry files = 2;
inline int Tree::files_size() const {
  return files_.size();
}
inline void Tree::clear_files() {
  files_.Clear();
}
inline const ::Lyekka::pb::FileEntry& Tree::files(int index) const {
  return files_.Get(index);
}
inline ::Lyekka::pb::FileEntry* Tree::mutable_files(int index) {
  return files_.Mutable(index);
}
inline ::Lyekka::pb::FileEntry* Tree::add_files() {
  return files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::FileEntry >&
Tree::files() const {
  return files_;
}
inline ::google::protobuf::RepeatedPtrField< ::Lyekka::pb::FileEntry >*
Tree::mutable_files() {
  return &files_;
}

// -------------------------------------------------------------------

// Index

// required int64 date = 1;
inline bool Index::has_date() const {
  return _has_bit(0);
}
inline void Index::clear_date() {
  date_ = GOOGLE_LONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::int64 Index::date() const {
  return date_;
}
inline void Index::set_date(::google::protobuf::int64 value) {
  _set_bit(0);
  date_ = value;
}

// required string source = 2;
inline bool Index::has_source() const {
  return _has_bit(1);
}
inline void Index::clear_source() {
  if (source_ != &_default_source_) {
    source_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Index::source() const {
  return *source_;
}
inline void Index::set_source(const ::std::string& value) {
  _set_bit(1);
  if (source_ == &_default_source_) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void Index::set_source(const char* value) {
  _set_bit(1);
  if (source_ == &_default_source_) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void Index::set_source(const char* value, size_t size) {
  _set_bit(1);
  if (source_ == &_default_source_) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Index::mutable_source() {
  _set_bit(1);
  if (source_ == &_default_source_) {
    source_ = new ::std::string;
  }
  return source_;
}

// required bool complete = 3;
inline bool Index::has_complete() const {
  return _has_bit(2);
}
inline void Index::clear_complete() {
  complete_ = false;
  _clear_bit(2);
}
inline bool Index::complete() const {
  return complete_;
}
inline void Index::set_complete(bool value) {
  _set_bit(2);
  complete_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace Lyekka

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_main_2eproto__INCLUDED
